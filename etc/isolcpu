#!/bin/bash

#
# Filename:         /etc/libvirt/hooks/isolcpu
# Description:      Reserve/release CPU threads at start of Libvirt domain(s).
# URL(s):           https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#IO\_threads
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# <remarks>
# Save output to string for cpuset and cpumask
# Example:
#   Host:   0-1,8-9
#   Domain: 2-7,10-15
#
# Information
# cores     bit masks       mask
# 0-7       0b11111111      FF      # total cores
# 0,4       0b00010001      11      # host cores
#
# 0-11      0b111111111111  FFF     # total cores
# 0-1,6-7   0b000011000011  C3      # host cores
#
# </remarks>


FLAG_USE_HEX_MASKS=true
HOOK_NAME="isolcpu"
PREFIX_PROMPT="libvirt-qemu $HOOK_NAME:"
OPERATION="${2}"
GUEST_THREADS_DELIM=""
GUEST_THREADS_HEX=""
HOST_THREADS_DELIM=""
HOST_THREADS_HEX=""

function AreValuesNotEmpty
{
    if ( "${FLAG_USE_HEX_MASKS}" \
        && AreHexMasksNotEmpty  \
        && AreThreadSetsNotEmpty ) \
        || ( ! "${FLAG_USE_HEX_MASKS}" \
            && AreThreadSetsNotEmpty ); then
        return 0
    fi

    return 1
}

function AreHexMasksNotEmpty
{
    if [[ -z "${GUEST_THREADS_HEX}" ]] \
        || [[ -z "${HOST_THREADS_HEX}" ]]; then
        echo "${PREFIX_PROMPT} An error occured: Failed to get CPU hexadecimal masks."
        return 1
    fi

    return 0
}

function AreThreadSetsNotEmpty
{
    if [[ -z "${GUEST_THREADS_DELIM}" ]] \
        || [[ -z "${HOST_THREADS_DELIM}" ]]; then
        echo "${PREFIX_PROMPT} An error occured: Failed to get CPU thread sets."
        return 1
    fi

    return 0
}

function GetThreadByCoreAndSMT
{
    local -n REFERENCE="${1}"
    REFERENCE=$(( _CORE + ( SMT_FACTOR * TOTAL_CORES_COUNT )))
    return 0
}

function GetCPU
{
    AreValuesNotEmpty && return 0
    local -i CORES_ALLOCATED_TO_HOST=0
    local -i TOTAL_CORES_COUNT=$( cat /proc/cpuinfo | grep "cpu cores" | uniq | grep -o "[0-9]\+" )
    local -i TOTAL_THREADS_COUNT=$( cat /proc/cpuinfo | grep "siblings" | uniq | grep -o "[0-9]\+" )

    # <remarks>Set maximum number of cores allocated to host.</remarks>
    if [[ "${TOTAL_CORES_COUNT}" -ge 4 ]]; then
        CORES_ALLOCATED_TO_HOST=2

    elif [[ "${TOTAL_CORES_COUNT}" -le 3 ]] \
        && [[ "${TOTAL_CORES_COUNT}" -ge 2 ]]; then
        CORES_ALLOCATED_TO_HOST=1

    else
        echo "${PREFIX_PROMPT} An error occured: Insufficient CPU cores. Minimum is two (2) cores."
        return 1
    fi

    local -a HOST_CORES_LIST=( $( seq 0 $(( "${CORES_ALLOCATED_TO_HOST}" - 1 )) ) )
    local -a HOST_THREADS_LIST=( )
    local -a GUEST_CORES_LIST=( $( seq "${CORES_ALLOCATED_TO_HOST}" $(( "${TOTAL_CORES_COUNT}" - 1 )) ) )
    local -a GUEST_THREADS_LIST=( )
    local -i SMT_FACTOR=$(( "${TOTAL_THREADS_COUNT}" / "${TOTAL_CORES_COUNT}" ))
    local -a SMT_FACTOR_LIST=( $( seq 0 $(( "${SMT_FACTOR}" - 1 )) ) )

    AreValuesNotEmpty
    return "${?}"
}

function GetThreadSetsForHostAndLibvirt
{
    for SMT_FACTOR in ${SMT_FACTOR_LIST[@]}; do
        local -a GUEST_THREADS_DELIM_LIST=( )
        local -a HOST_THREADS_DELIM_LIST=( )
        local -i THREAD

        for _CORE in ${HOST_CORES_LIST[@]}; do
            GetThreadByCoreAndSMT "${THREAD}"
            HOST_THREADS_LIST+=( "${THREAD}" )
            HOST_THREADS_DELIM_LIST+=( "${THREAD}" )
        done

        for _CORE in ${GUEST_CORES_LIST[@]}; do
            GetThreadByCoreAndSMT "${THREAD}"
            GUEST_THREADS_LIST+=( "${THREAD}" )
            GUEST_THREADS_DELIM_LIST+=( "${THREAD}" )
        done

        local -i FIRST_THREAD_SET="${HOST_THREADS_DELIM_LIST[0]}"
        local -i LAST_THREAD_SET="${HOST_THREADS_DELIM_LIST[-1]}"

        local THREAD_SET="${FIRST_THREAD_SET}"

        if [[ "${FIRST_THREAD_SET}" -ne "${LAST_THREAD_SET}" ]]; then
            local THREAD_SET="$_FIRSTTHREAD_SET-${_LASTTHREAD_SET}"
        fi

        HOST_THREADS_DELIM+="${THREAD_SET},"

        local -i FIRST_THREAD_SET="${GUEST_THREADS_DELIM_LIST[0]}"
        local -i LAST_THREAD_SET="${GUEST_THREADS_DELIM_LIST[-1]}"
        local THREAD_SET="${FIRST_THREAD_SET}"

        if [[ "${FIRST_THREAD_SET}" -ne "${LAST_THREAD_SET}" ]]; then
            local THREAD_SET="${FIRST_THREAD_SET}-${_LASTTHREAD_SET}"
        fi

        GUEST_THREADS_DELIM+="${THREAD_SET},"
    done

    AreThreadSetsNotEmpty || return 1

    # <remarks>Truncate last delimiter.</remarks>
    if [[ ${HOST_THREADS_DELIM: -1} == "," ]]; then
        HOST_THREADS_DELIM="${HOST_THREADS_DELIM::-1}"
    fi

    if [[ ${GUEST_THREADS_DELIM: -1} == "," ]]; then
        GUEST_THREADS_DELIM="${GUEST_THREADS_DELIM::-1}"
    fi

    return 0
}

function GetHexMasksForHostAndLibvirt
{
    local -i HOST_THREADS_HEX_MASK=0
    local -i TOTAL_THREADS_HEX_MASK=0

    # <remarks>Add each decimal mask to sum.</remarks>
    for _THREAD in ${HOST_THREADS_LIST[@]}; do
        local -i THREAD_DECIMAL=$(( 2 ** ${_THREAD} ))
        local -i THREAD_HEX_MASK=$( echo "obase=16; ${THREAD}_DECIMAL" | bc )
        HOST_THREADS_HEX_MASK+="${THREAD_HEX_MASK}"
    done

    # <remarks>Convert hexadecimal mask into hexadecimal.</remarks>
    HOST_THREADS_HEX=$( printf '%x\n' "${HOST_THREADS_HEX_MASK}" )
    local -i TOTAL_THREADS_HEX_MASK=$(( ( 2 ** ${TOTAL_THREADS_COUNT} ) - 1 ))
    GUEST_THREADS_HEX=$( printf '%x\n' "${TOTAL_THREADS_HEX_MASK}" )
    AreHexMasksNotEmpty
    return "${?}"
}

function ReleaseHexMask
{
    if ! echo "${HOST_THREADS_HEX}" > /sys/bus/workqueue/devices/writeback/cpumask \
        || ! echo 0 > /sys/bus/workqueue/devices/writeback/numa; then
        echo "${PREFIX_PROMPT} An error occured: Failed to release CPU mask to Host."
        return 1
    fi

    echo "${PREFIX_PROMPT} Releasing CPU mask to Host."
}

function ReleaseThreadSets
{
    if ! systemctl set-property --runtime -- system.slice AllowedCPUs=${1} \
        || ! systemctl set-property --runtime -- user.slice AllowedCPUs=${1} \
        || ! systemctl set-property --runtime -- init.scope AllowedCPUs=${1}; then
        echo "An error occured: Failed to release CPU threads to Host."
        return 1
    fi

    echo "Releasing CPU threads to Host."
    return 0
}

function ReserveHexMask
{
    if ! echo "${GUEST_THREADS_HEX}" > /sys/bus/workqueue/devices/writeback/cpumask \
        || ! echo 1 > /sys/bus/workqueue/devices/writeback/numa; then
        echo "An error occured: Failed to reserve CPU mask to Libvirt domain(s)."
        return 1
    fi

    echo "Reserving CPU mask to Libvirt domain(s)."
    return 0
}

function ReserveThreadSets
{
    if ! systemctl set-property --runtime -- system.slice AllowedCPUs="${GUEST_THREADS_DELIM}" \
        || ! systemctl set-property --runtime -- user.slice AllowedCPUs="${GUEST_THREADS_DELIM}" \
        || ! systemctl set-property --runtime -- init.scope AllowedCPUs="${GUEST_THREADS_DELIM}"; then
        echo "${PREFIX_PROMPT} An error occured: Failed to reserve CPU threads to Libvirt domain(s)."
        return 1
    fi

    echo "${PREFIX_PROMPT} Reserving CPU threads to Libvirt domain(s)."
    return 0
}

function ReleaseOrReserveCPU
{
    case "${OPERATION}" in
        "started" )
            if "${FLAG_USE_HEX_MASKS}"; then
                ReserveHexMask || return 1
            fi

            ReserveThreadSets || return 1 ;;

        "release" )
            if "${FLAG_USE_HEX_MASKS}"; then
                ReleaseHexMask || return 1
            fi

            local -i LAST_THREAD_ID=$( cat /proc/cpuinfo | grep "siblings" | uniq | grep -o "[0-9]\+" )
            (( LAST_THREAD_ID-- ))
            local RELEASED_CPU_SET="0-${LAST_THREAD_ID}"
            ReleaseThreadSets "${RELEASED_CPU_SET}" || return 1 ;;
    esac

    return 0
}

if GetCPU; then
    ReleaseOrReserveCPU
fi